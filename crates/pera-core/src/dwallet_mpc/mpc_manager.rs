//! # Signature MPC Manager Module
//!
//! This module manages the lifecycle of Signature Multiparty Computation (MPC) sessions
//! within the Pera blockchain.
//! It ensures the proper initiation, handling, and finalization
//! of MPC sessions by tracking events, managing participants,
//! and coordinating communication between them.
//!
//! The main goal of this module is
//! to facilitate the cryptographic signing process in a decentralized setting.
//! It ensures
//! validators participate in signature MPC sessions
//! by sending and receiving messages according to protocol rules,
//! while also validating outputs to maintain integrity.
//!
//! ## Core Responsibilities
//! 1. Session Initiation and Management: The module creates and maintains active MPC sessions,
//! keeping track of messages and parties participating in each session.
//! 2. Event Handling: It listens for events,
//! such as the initiation and completion of MPC sessions,
//! emitted from the Pera blockchain.
//! 3. Consensus Submission:
//! The module interacts with the consensus layer
//! to submit transactions related to session outputs and intermediate messages.
//! 4. Output Verification: Ensures that the generated output matches what is expected,
//! preventing malicious behavior.
//! 5. Malicious Activity Detection:
//! Identifies and handles invalid or malicious behaviors,
//! such as validators sending multiple messages within a single round.
//!
//! ## Flow Summary
//! — Message Passing and Ordering:
//! Validators exchange messages related to the MPC session as regular transactions,
//! which go through the consensus process and are ordered accordingly.
//! - Handling Signature MPC Output:
//! When a validator detects a [`ConsensusTransactionKind::DwalletMPCOutput`] transaction,
//! it verifies that the output matches what was generated locally for the session.
//! - Output Storage and Event Emission: Once verified,
//! the validator stores the output on-chain and emits a [`CompletedProofMPCSessionEvent`],
//! indicating the session's completion.
//! - Session Finalization: Upon completion, the module updates the session status,
//! emits events to notify the network, and decrements the active session counter.
//!
//! ## Architecture
//! This module integrates with various components, including
//! — [`AuthorityPerEpochStore`]: Provides access to the committee and
//! validator state for the current epoch.
//! — [`ConsensusAdapter`]: Facilitates interaction with the consensus layer for submitting
//! transactions.
//! — MPCEvent Handling: Detects and processes [`CreatedProofMPCEvent`] and
//! [`CompletedProofMPCSessionEvent`] to manage MPC sessions.
//! — [`DwalletMPCInstance`]: Manages individual MPC sessions, including tracking messages,
//! advancing the cryptographic steps, and verifying outputs.
//!
//! ## Handling Messages and Outputs
//! — Messages: Messages are collected until a threshold is reached,
//! at which point the session advances to the next cryptographic step.
//! - Outputs:
//! The module verifies
//! that the output generated by the MPC session matches the expected result before finalizing it.
//!
//! ## Parallelization and Performance
//! This module uses Rayon for parallelizing operations across multiple MPC instances,
//! ensuring high performance when processing large numbers of sessions concurrently.
//!
//! ## Fault Tolerance
//! — Epoch Transitions:
//! The module ensures smooth handling of session data across epoch changes
//! by validating the authority's presence in the committee.
//! - Validator Punishment: Detects and punishes validators that behave maliciously,
//! such as sending multiple messages within a single round or submitting invalid messages.
use crate::authority::authority_per_epoch_store::AuthorityPerEpochStore;
use crate::consensus_adapter::{SubmitToConsensus};
use crate::dwallet_mpc::mpc_events::{CreatedProofMPCEvent, MPCEvent};
use group::{GroupElement, PartyID};
use itertools::Itertools;
use mpc::party::Advance;
use mpc::{two_party::Round, AdvanceResult};
use pera_types::base_types::{AuthorityName, ObjectID, PeraAddress};
use pera_types::error::{PeraError, PeraResult};
use pera_types::event::Event;
use pera_types::messages_consensus::ConsensusTransaction;

use pera_types::committee::EpochId;
use rand_core::OsRng;
use rayon::prelude::*;
use schemars::_private::NoSerialize;
use serde::{Deserialize, Serialize};
use std::cmp::PartialEq;
use std::collections::{HashMap, HashSet, VecDeque};
use std::future::Future;
use std::io::Write;
use std::sync::{Arc, Weak};
use tracing::{debug, error, info};

/// The message a Validator can send to the other parties while running a signature MPC session.
#[derive(Clone)]
struct DWalletMPCMessage {
    /// The serialized message.
    message: Vec<u8>,
    /// The authority that sent the message.
    authority: AuthorityName,
}

// TODO (#283): Remove this trait
/// A wrapper for the generic Party trait that allows creating new instances of
/// the Party from only the threshold.
/// Should be implemented internally in newer versions of the [`proof`] crate.
pub trait CreatableParty: Advance {
    /// The MPC Manager will create a new mpc instance after the `InitEvent` is received.
    type InitEvent: MPCEvent + Serialize + for<'a> Deserialize<'a>;
    /// The MPC Manager will finalize the mpc instance after `FinalizeEvent` is received.
    type FinalizeEvent: MPCEvent + Serialize + for<'a> Deserialize<'a>;
    /// Create a new instance of the party.
    fn new(parties: HashSet<PartyID>, party_id: PartyID) -> Self;
}

/// Represents the possible statuses of an MPC (Multiparty Computation) session.
///
/// This enum defines the various stages of an MPC session, from when it is active
/// to when it has been finalized or finished.
/// Each status impacts how incoming messages
/// are handled and whether the session is eligible for further processing.
///
/// # Variants
///
/// - `Active`:
///   The session is currently running.
///   - New messages are accepted and forwarded to the session for processing.
///
/// - `Finalizing(Output)`:
///   The session has completed its cryptographic operations and is awaiting final removal.
///   - No new messages are accepted at this stage.
///   - The output data (of type `Output`) is prepared for verification or submission.
///
/// - `Finished(Output)`:
///   The session is no longer active and has been removed from the list of running instances.
///   - Messages sent to this session are ignored, but they are not flagged as malicious.
///   - The session output (of type `Output`) is still accessible for reference or audit.
#[derive(Clone, Copy, PartialEq, Debug)]
enum MPCSessionStatus<Output> {
    Active,
    Finalizing(Output),
    Finished(Output),
}

/// Convert a given authority name (address) to it's corresponding party ID.
/// The party ID is the index of the authority in the committee.
fn authority_name_to_party_id(
    authority_name: AuthorityName,
    epoch_store: &AuthorityPerEpochStore,
) -> PeraResult<PartyID> {
    Ok(epoch_store
        .committee()
        .authority_index(&authority_name)
        // This should never happen,
        // as the validator only accepts messages from committee members.
        .ok_or_else(|| {
            PeraError::InvalidCommittee(
                "received a proof MPC message from a validator that is not in the committee"
                    .to_string(),
            )
        })? as PartyID)

}
/// Signature MPC Session Instance.
/// It keeps track of the session status, the channel to send messages to the instance,
/// and the messages that are pending to be sent to the instance.
struct DwalletMPCInstance<Party: CreatableParty> {
    status: MPCSessionStatus<Party::OutputValue>,
    /// The messages that are pending to be executed while advancing the instance.
    /// We need to accumulate a threshold of those before advancing the instance.
    // todo: https://github.com/dwallet-labs/dwallet-network/pull/280/files#r1807744916
    pending_messages: HashMap<PartyID, Party::Message>,
    consensus_adapter: Arc<dyn SubmitToConsensus>,
    epoch_store: Weak<AuthorityPerEpochStore>,
    epoch_id: EpochId,
    /// The total number of parties in the chain.
    /// We can calculate the threshold and party's IDs (indexes) from it.
    /// To calculate the party's ID, all we need to know is the number of parties,
    /// as the IDs are just the indexes of those parties.
    /// If there are three parties, the IDs are [0, 1, 2].
    number_of_parties: usize,
    session_id: ObjectID,
    sender_address: PeraAddress,
    /// The MPC party being used to run the MPC cryptographic steps.
    /// `Option` because it can be `None` before the instance has started.
    party: Option<Party>,
}

impl<P: CreatableParty> DwalletMPCInstance<P> {
    fn new(
        consensus_adapter: Arc<dyn SubmitToConsensus>,
        epoch_store: Weak<AuthorityPerEpochStore>,
        epoch: EpochId,
        session_id: ObjectID,
        sender_address: PeraAddress,
        number_of_parties: usize,
    ) -> Self {
        Self {
            status: MPCSessionStatus::Active,
            pending_messages: HashMap::new(),
            consensus_adapter: consensus_adapter.clone(),
            epoch_store: epoch_store.clone(),
            epoch_id: epoch,
            session_id,
            sender_address,
            party: None,
            number_of_parties,
        }
    }

    fn epoch_store(&self) -> PeraResult<Arc<AuthorityPerEpochStore>> {
        self.epoch_store
            .upgrade()
            .ok_or(PeraError::EpochEnded(self.epoch_id))
    }

    /// Advances the MPC instance by processing the accumulated messages
    /// or initializing a new party if needed.
    ///
    /// This function handles progressing the MPC session.
    /// If the session already has an existing
    /// party instance, it continues the process with it.
    /// If not, it creates a new party based on the
    /// participating validators, and their assigned IDs.
    fn advance(&mut self, auxiliary_input: &P::AuxiliaryInput) -> PeraResult<()> {
        // Take ownership of the current party, or create a new one if it's the first advance.
        let party = self
            .party
            .take()
            // todo(zeev): error handling
            .unwrap_or_else(|| self.initialize_party().unwrap());

        // Attempt to advance the party using the pending messages and auxiliary input.
        // TODO (#263): Mark and punish the malicious validators that caused this advance to fail
        let Ok(advance_result) =
            party.advance(self.pending_messages.clone(), auxiliary_input, &mut OsRng)
        else {
            // TODO (#263): Mark and punish the malicious validators that caused this advance to fail
            self.pending_messages.clear();
            return Ok(());
        };

        // Handle the result of the advance: either continue or finalize the session.
        let message = match advance_result {
            AdvanceResult::Advance((msg, updated_party)) => {
                self.pending_messages.clear();
                self.party = Some(updated_party);
                self.new_dwallet_mpc_message(msg)
            }
            AdvanceResult::Finalize(output) => {
                // TODO (#238): Verify the output and write it to the chain
                self.status = MPCSessionStatus::Finalizing(output.clone().into());
                self.new_proof_mpc_output_message(output.into())
            }
        };

        // Submit the message asynchronously, if available.
        if let Some(msg) = message {
            let consensus_adapter = Arc::clone(&self.consensus_adapter);
            let epoch_store = Arc::clone(&self.epoch_store()?);
            // Spawn sends this message asynchronously via a thread
            // so that [`self.advance`] function will stay synchronous,
            // and can be parallelized with Rayon.
            tokio::spawn(async move {
                let _ = consensus_adapter
                    .submit_to_consensus(&[msg], &epoch_store)
                    .await;
            });
        }

        Ok(())
    }

    /// Initializes a new party instance with the participating validators.
    fn initialize_party(&self) -> PeraResult<P> {
        let parties: HashSet<_> = (0..self.number_of_parties).map(|i| i as PartyID).collect();
        let party_id =
            authority_name_to_party_id(self.epoch_store()?.name, &*(self.epoch_store()?))?;
        Ok(P::new(parties, party_id))
    }

    /// Create a new consensus transaction with the message to be sent to the other MPC parties.
    /// Returns `None` only if the epoch switched in the middle and was not available.
    fn new_dwallet_mpc_message(&self, message: P::Message) -> Option<ConsensusTransaction> {
        self.epoch_store().ok().map(|epoch_store| {
            ConsensusTransaction::new_dwallet_mpc_message(
                epoch_store.name,
                bcs::to_bytes(&message).unwrap(),
                self.session_id.clone(),
            )
        })
    }

    /// Create a new consensus transaction with the flow result
    /// (output) to be sent to the other MPC parties.
    /// Returns None if the epoch switched in the middle and was
    /// not available or if this party is not the aggregator.
    /// Only the aggregator party should send the output to the other parties.
    fn new_proof_mpc_output_message(&self, output: P::OutputValue) -> Option<ConsensusTransaction> {
        self.epoch_store().ok().and_then(|epoch_store| {
            authority_name_to_party_id(epoch_store.name, &epoch_store)
                .ok()
                // todo: https://github.com/dwallet-labs/dwallet-network/pull/280/files#r1808562659
                .filter(|&party_id| party_id == 3)
                .and_then(|_| {
                    bcs::to_bytes(&output).ok().map(|output_bytes| {
                        ConsensusTransaction::new_dwallet_mpc_output(
                            output_bytes,
                            self.session_id.clone(),
                            self.sender_address.clone(),
                        )
                    })
                })
        })
    }

    /// Stores a message in the pending messages map for the current MPC instance.
    ///
    /// If the message is from an already recorded party within the same round, it will be ignored
    /// (as each party can send only one message per round).
    /// When all required messages are received, the instance will be advanced.
    fn store_message(
        &mut self,
        message: &DWalletMPCMessage,
        epoch_store: Arc<AuthorityPerEpochStore>,
    ) -> PeraResult<()> {
        let party_id = authority_name_to_party_id(message.authority, &epoch_store)?;

        // Ignore duplicate messages from the same party within the same round.
        if self.pending_messages.contains_key(&party_id) {
            // TODO (#260): Punish authority for sending multiple messages in the same round.
            return Ok(());
        }

        // Attempt to deserialize the message and store it if successful.
        bcs::from_bytes(&message.message)
            .map(|msg| {
                self.pending_messages.insert(party_id, msg);
            })
            .map_err(|err| PeraError::ObjectDeserializationError {
                // TODO (#310): Mark and punish a validator that sends a message that cannot be deserialized
                error: err.to_string(),
            })
    }

    /// Handles a message by either forwarding it to the instance or ignoring
    /// it if the instance is finished.
    fn handle_message(&mut self, message: DWalletMPCMessage) -> PeraResult<()> {
        match self.status {
            MPCSessionStatus::Active => self.store_message(&message, self.epoch_store()?),
            // TODO (#263): Check for malicious messages also after the instance is finished
            MPCSessionStatus::Finalizing(_) | MPCSessionStatus::Finished(_) => {
                // Do nothing.
                Ok(())
            }
        }
    }
}

/// Manages the lifecycle and execution of Signature MPC (Multiparty Computation) instances.
///
/// The [`DwalletMPCManager`] responsible for tracking, activating,
/// and managing MPC instances, ensuring smooth
/// cryptographic processes across multiple parties in the network.
/// It coordinates message flow, handles the state of
/// each instance,
/// and ensures that only a limited number of instances are active at any given time.
/// # Responsibilities
/// — Instance Management: Keeps track of all MPC instances using a `HashMap`.
/// — Activation Order:
/// Ensures pending instances are activated in the order they are received, using a queue.
/// — Execution and Deactivation: Executes active instances and deactivates them once completed.
/// todo: rename and https://github.com/dwallet-labs/dwallet-network/pull/280/files#r1807766408.
pub struct DwalletMPCManager<P: CreatableParty> {
    // todo: https://github.com/dwallet-labs/dwallet-network/pull/280/files#r1807766541
    mpc_instances: HashMap<ObjectID, DwalletMPCInstance<P>>,
    /// Used to keep track of the order in which pending instances are received,
    /// so they are activated in order of arrival.
    pending_instances_queue: VecDeque<ObjectID>,
    // TODO (#257): Make sure the counter is always in sync with the number of active instances.
    active_instances_counter: usize,
    consensus_adapter: Arc<dyn SubmitToConsensus>,
    pub epoch_store: Weak<AuthorityPerEpochStore>,
    pub max_active_mpc_instances: usize,
    // todo: https://github.com/dwallet-labs/dwallet-network/pull/280/files#r1808589063
    auxiliary_input: P::AuxiliaryInput,
    pub epoch_id: EpochId,
    /// The total number of parties in the chain
    /// We can calculate the threshold and parties IDs (indexes) from it.
    number_of_parties: usize,
}

/// Needed to be able to iterate over a vector of generic MPCInstances with `Rayon`.
unsafe impl<P: CreatableParty + Sync + Send> Send for DwalletMPCInstance<P> {}

impl<P: CreatableParty + Sync + Send> DwalletMPCManager<P> {
    pub fn new(
        consensus_adapter: Arc<dyn SubmitToConsensus>,
        epoch_store: Weak<AuthorityPerEpochStore>,
        epoch_id: EpochId,
        max_active_mpc_instances: usize,
        number_of_parties: usize,
        auxiliary_input: P::AuxiliaryInput,
    ) -> Self {
        Self {
            mpc_instances: HashMap::new(),
            pending_instances_queue: VecDeque::new(),
            active_instances_counter: 0,
            consensus_adapter,
            epoch_store,
            epoch_id,
            max_active_mpc_instances,
            // TODO (#268): Take into account the validator's voting power
            auxiliary_input,
            number_of_parties,
        }
    }

    /// Verifies whether the received MPC session output matches the locally generated one.
    ///
    /// This function checks if the stored output in a finalizing MPC instance
    /// matches the provided output.
    /// If the session is either not found or not in the `Finalizing`
    /// state, the verification will return `false`.
    ///
    /// # Returns
    /// — `Ok(true)` if the outputs match.
    /// — `Ok(false)` if the session does not exist, is not finalizing, or the outputs don't match.
    /// — `Err` if deserialization of the provided output fails.
    // TODO (#311): Make validator don't mark other validators as malicious or take any active action while syncing
    pub fn try_verify_output(
        &self,
        output: &Vec<u8>,
        session_id: &ObjectID,
    ) -> anyhow::Result<bool> {
        // todo: https://github.com/dwallet-labs/dwallet-network/pull/280/files#r1808919404
        self.mpc_instances
            .get(session_id)
            .filter(|instance| matches!(instance.status, MPCSessionStatus::Finalizing(_)))
            .and_then(|instance| match &instance.status {
                MPCSessionStatus::Finalizing(stored_output) => bcs::from_bytes(output)
                    .ok()
                    .map(|decoded: P::OutputValue| decoded == *stored_output),
                _ => None,
            })
            // todo(zeev): fix error.
            .ok_or_else(|| anyhow::Error::msg("output verification failed"))
    }

    /// Filter the relevant MPC events from the transaction events and handle them
    /// Create new MPC instances when receiving a [`CreatedProofMPCEvent`],
    /// and decrease the [`active_instances_counter`]
    /// when receiving a [`CompletedProofMPCSessionEvent`].
    /// Processes relevant MPC events from the provided transaction events.
    ///
    /// This function filters out and handles specific MPC events:
    /// - `CreatedProofMPCEvent`: Creates a new MPC instance upon receiving this event.
    /// - `CompletedProofMPCSessionEvent`:
    /// Finalizes the MPC instance and decrements the active instances counter.
    ///
    /// # Returns
    /// — `Ok(())` if all events are successfully processed.
    /// — `Err` if any event fails to deserialize, or an MPC instance cannot be finalized.
    pub fn event_handler(&mut self, events: &Vec<Event>) -> anyhow::Result<()> {
        events.iter().try_for_each(|event| {
            if P::InitEvent::type_() == event.type_ {
                let deserialized_event = bcs::from_bytes(&event.contents)?;
                self.push_new_mpc_instance(deserialized_event);
                debug!("event: Init MPC Session {:?}", event);
            }

            if P::FinalizeEvent::type_() == event.type_ {
                let deserialized_event = bcs::from_bytes(&event.contents)?;
                self.finalize_mpc_instance(deserialized_event)?;
                debug!("event: Finalize MPC Session {:?}", event);
            }

            Ok(())
        })
    }

    /// Advances all eligible MPC instances that either:
    /// 1. Have received the required number of messages.
    /// 2. We Need to perform the first step of the flow without an initialized party.
    ///
    /// The advances are executed in parallel using `Rayon` to improve performance.
    /// If any instance encounters an issue during its advance, an error will be returned.
    ///
    /// # Behavior
    /// — Eligibility Check: Instances with sufficient messages, or
    /// those needing initialization are selected.
    /// — Parallel Execution: Advances are performed
    /// concurrently using `par_iter_mut()` from `Rayon`.
    /// — Error Handling: If any instance fails to advance,
    /// the process stops, and the error is propagated.
    ///
    /// # Returns
    /// — `Ok(())` if all instances advance successfully.
    /// — `Err` if any instance fails during the advance process.
    ///
    // TODO (#263): Implement logic to mark and punish validators responsible for failed advances.
    // TODO (#268): Take the voting power into account when dealing with the threshold
    pub async fn handle_end_of_delivery(&mut self) -> PeraResult<()> {
        let threshold = ((self.number_of_parties * 2) + 2) / 3;

        // Collect instances that are ready to advance.
        let mut ready_to_advance: Vec<_> = self
            .mpc_instances
            .iter_mut()
            .filter_map(|(_, instance)| {
                let should_advance = instance.status == MPCSessionStatus::Active
                    && (instance.pending_messages.len() >= threshold || instance.party.is_none());
                should_advance.then_some(instance)
            })
            .collect();

        // Perform advances in parallel using Rayon.
        ready_to_advance
            .par_iter_mut()
            .map(|instance| instance.advance(&self.auxiliary_input))
            // Stop on the first error and propagate it.
            .collect::<PeraResult<_>>()?;

        Ok(())
    }

    /// Forwards an incoming message to the appropriate MPC instance for processing.
    ///
    /// If the specified MPC instance does not exist,
    /// an error is logged, and the sender is subject to punishment.
    ///
    /// # Behavior
    /// — If the MPC instance exists, the message is forwarded to it for handling.
    /// — If the instance is not found,
    /// the function logs an error and completes without taking further action.
    ///
    /// # Returns
    /// — `Ok(())` if the message was successfully forwarded or if the instance was not found.
    /// — `Err` if forwarding the message to the MPC instance fails.
    ///
    // TODO (#261): Implement punishment logic for validators sending messages
    // TODO (#261): to non-existing MPC instances.
    // todo: https://github.com/dwallet-labs/dwallet-network/pull/280/files#r1798889640
    pub fn handle_message(
        &mut self,
        message: &[u8],
        authority_name: AuthorityName,
        session_id: ObjectID,
    ) -> PeraResult<()> {
        match self.mpc_instances.get_mut(&session_id) {
            Some(instance) => instance.handle_message(DWalletMPCMessage {
                message: message.to_vec(),
                authority: authority_name,
            }),
            None => {
                error!(
                    "received a message for a non-existent instance: {:?}",
                    session_id
                );
                // TODO (#261): Punish validators sending messages to non-existing instances.
                Ok(())
            }
        }
    }

    /// Spawns a new MPC instance if the number of active instances is within the allowed limit.
    /// If the limit is exceeded, the new instance is added to the pending queue for
    /// later activation.
    ///
    /// # Behavior
    /// — Duplicate Check: If the session ID already exists, logs an error and exits.
    /// — Active Instances Limit:
    /// If the active instances limit is reached, the instance is queued for future activation.
    /// — Instance Creation:
    /// If the limit allows, creates a new MPC instance and registers it with the manager.
    ///
    /// # Logging
    /// — Logs relevant information when an instance is added to the manager or the pending queue.
    /// — Logs an error if an attempt is made to create a duplicate instance.
    fn push_new_mpc_instance(&mut self, event: P::InitEvent) {
        let session_id_bytes = event.session_id().bytes;

        // Ensure the session ID is unique.
        // This should never happen, as the session ID is a move UniqueID.
        if self.mpc_instances.contains_key(&session_id_bytes) {
            error!(
                "received start flow event for duplicate session ID: {:?}",
                event.session_id()
            );
            return;
        }

        info!(
            "Received start flow event for session ID: {:?}",
            event.session_id()
        );

        // Queue the instance if the active limit is reached.
        // TODO (#311): Make validator don't mark other validators as malicious or take any active action while syncing.
        if self.active_instances_counter >= self.max_active_mpc_instances {
            self.pending_instances_queue.push_back(session_id_bytes);
            info!(
                "Added MPCInstance to pending queue for session ID: {:?}",
                event.session_id()
            );
            return;
        }

        // Create and register the new MPC instance.
        let new_instance = DwalletMPCInstance::new(
            Arc::clone(&self.consensus_adapter),
            self.epoch_store.clone(),
            self.epoch_id,
            session_id_bytes.clone(),
            event.event_emitter().clone(),
            self.number_of_parties,
        );

        self.mpc_instances.insert(session_id_bytes, new_instance);
        self.active_instances_counter += 1;

        info!(
            "Added MPCInstance to MPC manager for session ID: {:?}",
            event.session_id()
        );
    }

    /// Finalizes the specified MPC instance, transitioning it
    /// from the `Finalizing` state to `Finished`.
    ///
    /// # Behavior
    /// — If the session is found and in the `Finalizing` state, it transitions to `Finished`,
    ///   decrements the active instances counter, and logs the completion.
    /// — If the session is not found or not in the `Finalizing` state, an error is returned.
    ///
    /// # Returns
    /// — `Ok(())` if the instance is successfully finalized.
    /// — `Err(PeraError::InvalidCommittee)` if the session does not exist.
    /// — `Err(PeraError::Unknown)` if the session is not in the `Finalizing` state.
    pub fn finalize_mpc_instance(&mut self, event: P::FinalizeEvent) -> PeraResult<()> {
        let session_id = event.session_id().bytes;

        // Retrieve the MPC instance or return an error if it doesn't exist.
        let instance = self.mpc_instances.get_mut(&session_id).ok_or_else(|| {
            // todo: https://github.com/dwallet-labs/dwallet-network/pull/280/files#r1807810448
            PeraError::InvalidCommittee(format!(
                "received a `finalize` event for non-existent session ID: `{:?}`",
                event.session_id()
            ))
        })?;

        // Check if the instance is in the finalizing state and transition it to `Finished`.
        match &instance.status {
            MPCSessionStatus::Finalizing(output) => {
                instance.status = MPCSessionStatus::Finished(output.clone());
                self.active_instances_counter -= 1;

                info!(
                "Finalized MPCInstance for session ID: `{:?}`",
                event.session_id()
            );

                Ok(())
            }
            // todo: https://github.com/dwallet-labs/dwallet-network/pull/280/files#r1809022864
            _ => Err(PeraError::Unknown(format!(
                "received a `finalize` event for session ID: `{:?}` that is not in the finalizing state; current state: {:?}",
                event.session_id(),
                instance.status
            ))),
        }
    }
}
